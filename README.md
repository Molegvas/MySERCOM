#          Адаптер силового блока зарядного устройства

##   Кратко 

Адаптер силового блока предназначен для соединения управляющего контроллера с силовым блоком. Центральный микроконтроллер освобождается от исполнения рутинных операций.

 ### Аппаратная поддержка
   Прототипирование выполнялось на плате SAMD21-M0-Mini. Подробности включения хорошо описаны в https://github.com/BLavery/SAMD21-M0-Mini.
  К сожалению поддержка Arduino не в полной мере соответствует потребностям проекта, но это преодолимо.

 #### Особенности прототипирования на плате SAMD21-M0-Mini
  В качестве инструкции:  https://github.com/BLavery/SAMD21-M0-Mini:
 * select the board: Tools/Board = Arduino SAMD / "Arduino Zero (Native USB Port)".
 * Double-click the board reset button. Upload. See if a LED blinks.
 explain a bit:
 1. The Arduino bootloader uses double click on reset button to enter flash upload mode. Single
    reset enters normal running mode.
 2. The serial/bossac mode of USB upload is included in the Arduino install.
 3. The regular user LED is missing. So we choose one of the TX/RX LEDs. For the moment, 
    the Arduino sketch is NOT otherwise driving these as TX/RX indicators (see above), 
    so we can re-employ them.
 4. But what pin or GPIO number? For this board, reference the pins as 0-26 or A0-A5. Not D25, 
    nor PB03 or PB3.

 ### Обмен между контроллерами.

*  Протокол WAKE является логическим уровнем интерфейса управления оборудованием с помощью асинхронного последовательного канала. Физический уровень интерфейса протоколом не определяется, может использоваться, например, RS-232, RS-485 или USB. Протокол позволяет производить обмен пакетами данных (data frames) длиной до 255 байт с адресуемыми устройствами, которых может быть до 127. Формат данных может быть любым. Могут передаваться байтовые поля, многобайтовые слова или строки символов. Для контроля правильности передачи данных используется контрольная сумма (CRC-8).
* Подробная информация о WAKE: http://leoniv.diod.club/articles/wake/wake.html
Выбор этого протокола объясняется тем, что хорошо известен автору и многолетней работой доказал свою надежность в устройстве ротации кондиционеров.
* Первоначальные планы использовать в качестве физического носителя SPI разбились о прозу жизни - в наличии не оказалось соответствующего адаптера USB-3SPI. Для целей прототипирования используется USB-UART терминал WakeUp! от Ридико Леонида Ивановича. Найдете в "resources".
* Передача параметров из нескольких байт: сначала старший, потом младшие.
* Время ожидания ответа ограничено 1000мс.  

 ### Управление измерениями.

 #### Измерение напряжения
   Измерение напряжения предполагается в диапазоне от -0,2В до +20,0В. Режим АЦП - дифференциальный. Опорное напряжение и усиление - выбор есть. Если получится реализовать вариант со сдвигом по напряжению на 200мВ минусовой клеммы, то обработка неправильной полярности подключения не потребует аппаратной поддержки. 

 #### Измерение тока
   Измерение тока в диапазоне от -16 до +16 ампер на токоизмерительном шунте укладывается в диапазон входного напряжения от -160 до +160мВ. Режим АЦП - дифференциальный. Пороги аварийного отключения не выставлялись.
 #### Измерение тока разряда
Зарезервировано. 
 #### Измерение температуры
```c++
// MF52AT MF52 B 3950 NTC термистор 2% 10 kOm
const float reference_resistance = 10000.0;    // 10kOm 1%
const float nominal_resistance   = 10000.0;    // 10kOm 2%
const float nominal_temperature  =    25.0;
const float b_value              =  3950.0;

float readSteinhart( const int adc )
{
// https://neyasyt.ru/uploads/files/termistor-NTC-10-K-MF52.pdf
  float steinhart;
  //float tr = 4095.0 / adc - 1.0;

  float tr = 3.30f / readVoltage( adc ) - 1.0f;

  tr = reference_resistance / tr;
  steinhart = tr / nominal_resistance;                  // (R/Ro)
  steinhart = log(steinhart);                           // ln(R/Ro)
  steinhart /= b_value;                                 // 1/B * ln(R/Ro)
  steinhart += 1.0f / (nominal_temperature + 273.15f);  // + (1/To)
  steinhart = 1.0f / steinhart;                         // Invert
  steinhart -= 273.15f;
  if ( steinhart == -273.15f ) steinhart = 120.0f;
  return ( steinhart > 120.0f ) ? 120.0f : steinhart;
}
```
* Конфигурирование канала измерения состоит из параметров АЦП (разрядность, усреднение, см. страницы 853 и 862) и датчика (опорное напряжение, усиление, приборное смещение, коэффициент преобразования данных в физическую величину).
* В ответ контроллер отправляет пакет, содержащий байт ошибки (зарезервированная позиция), двухбайтный код АЦП и двухбайтное значение измеренной величины (для напряжения - в милливольтах).
* Команды такого типа скорее исследовательские, служащие для поиска оптимальных конфигураций.
* Выбор параметров, предложенных в datasheet ... как говорится, "не все йогурты одинаково полезны" ... 
* Аппаратное смещение задается отдельной командой, усиление - не исследовалось.      
* Ниже дано пояснение формата команды на примере конфигурирования измерителя напряжения.
```c++
// Настройка измерителя напряжения (код команды 0x55  'cmd_set_adc_bat')     
void doAdcBat()
{
    if( rxNbt == 10 )		  // Проверка получения полного пакета
  {
    uint8_t err           = 0x00;
    constexpr uint8_t prb = 0x00; // Измеритель напряжения, в [] - ориентировочные параметры
      // Задать все параметры измерителя [ 01 00 00 03 04 00 0000 12BA ]
    adcBits     [prb] = rxDat[0]; // Разрешение: 0x00(12), [0x01(16)], 0x02(10),  0x03(8)
    prbReference[prb] = rxDat[1]; // Опорное:   [0x00(1V)], 0x01(1/1.48VDDA),     0x02(1/2VDDA), 0x03(ExtA)
    prbGain     [prb] = rxDat[2]; // Усиление:  [0x00(X1)], 0x01(X2),  0x03(X4),  0x04(X8),      (X16), (DIV2)    
    adcSamples  [prb] = rxDat[3]; // Накопление: 0x00(1),   0x01(2),   0x02(4),  [0x03(8)],      0x04(16), ... 0x0a
    adcDivider  [prb] = rxDat[4]; // Делитель:   0x00(2^0), 0x01(2^1), 0x02(2^2), 0x03(2^3),    [0x04(2^4)]... 0x07
    refComp    = 0x01 & rxDat[5]; // 0/1: выкл/вкл аппаратное смещение АЦП
    prbOffset   [prb] = get16(6); // Приборное смещение: 0x8000 ... 0x7fff
    prbDivider  [prb] = get16(8); // Коэффициент преобразования в милливольты:   [0x12ba]
      // Считать результат
                                          // Нулевой байт - ошибка параметра (зарезервировано)
    txDat[1] = ( adcVoltage >> 8) & 0xFF; // Hi
    txDat[2] =   adcVoltage       & 0xFF; // Lo
    txDat[3] = ( voltage >> 8)    & 0xFF; // Hi
    txDat[4] =   voltage          & 0xFF; // Lo

    txReplay( 5, err );		  // Ответ из 5 байт
  }
  else
  {
    txReplay(1, err_tx);	  // Передается код ошибки протокола
  }
}
```

 ### PID-регулирование.

  Для прототипирования выбран быстрый 32-битный пид-регулятор с фиксированной точкой для Arduino:
FastPID v1.3.1 by Mike Matera 
https://github.com/mike-matera/FastPID

  Этот пид-регулятор работает быстрее, поскольку он позволяет избежать дорогостоящих операций с плавающей запятой. Пид-регулятор сконфигурирован с коэффициентами с плавающей запятой и переводит их в фиксированную точку внутренне. Это накладывает ограничения на область применения коэффициентов. Установка условий I и D на ноль ускоряет работу регулятора. Регулятор сконфигурирован для работы на фиксированной частоте, и вызывающий код отвечает за работу на этой частоте. Параметры Ki и Kd масштабируются по частоте, чтобы сэкономить время во время операции step(). 

 #### Описание коэффициентов регулирования

  * Kp - пропорциональный 
  * Ki - интегральный 
  * Kd - дифференциальный 
  * Hz - частота выполнения контроллера 

#### Диапазон значений коэффициентов 

Конвейер вычислений ожидает 16-битные коэффициенты. Это контролируется PARAM_BITS и не должно быть изменено, иначе может возникнуть нежелательное переполнение. Количество битов до и после десятичного знака контролируется параметром PARAM_SHIFT в FastPID.h. значение по умолчанию для PARAM_SHIFT равно 8 и может быть изменено в соответствии с вашим приложением.

  * Диапазон параметра P от 0.00390625 до 255 включительно.** 
  * Параметр I равен P / Hz** 
  * Параметр D равен P * Hz** 
* ** До выяснения реальной потребности в диапазоне диапазон P установлен от 0,01 до 255.
Регулятор проверяет наличие нарушений диапазона параметров и не будет работать, если коэффициент находится вне диапазона. Все операции конфигурации возвращают bool, чтобы предупредить пользователя об ошибке. Функция err() проверяет состояние ошибки. Ошибки можно устранить с помощью функции clear().

#### Частота Выполнения

* ** Частота выполнения не определяется автоматически, это значительно повышает производительность регулятора. Вместо этого Ki и Kd масштабируются на этапе настройки. Очень важно вызывать step() с той скоростью, которую вы укажете. 

#### Вход и выход

Входной сигнал и заданное значение являются int16_t, что соответствует разрядности АЦП и позволяет разместить отрицательные показания и заданные значения. Выходные данные PID - это int16_t. Фактическая битовая ширина и знаковость вывода могут быть настроены. 
  
  * bits - выходная ширина будет ограничена значениями внутри этого битового диапазона. Допустимые значения от 1 до 16 
  * sign если true, то выходной диапазон равен от -2^(бит-1) до -2^(бит-1) -1. Если выходной диапазон false, то от 0 до 2^(бит-1)-1. 
  * ** Максимальное выходное значение контроллера -32767 (даже в 16-битном беззнаковом режиме) ** 

#### Исполнение

Производительность FastPID варьируется в зависимости от коэффициентов. Когда коэффициент равен нулю, выполняется меньший расчет**. 

|  Kp |  Ki |  Kd | Step Time (uS) |  
| --- | --- | --- | -------------- |
| 0.1 | 0.5 | 0.1 |      ~64       | 
| 0.1 | 0.5 | 0   |      ~56       | 
| 0.1 | 0   | 0   |      ~28       | 

* ** На данный момент не проверялось.

#### ПРИКЛАДНОЙ ПРОГРАММНЫЙ ИНТЕРФЕЙС (API)
Здесь и далее приводится авторский текст из указанного первоисточника с незначительными изменениями.

API стремится быть простым и понятным. Я не буду имплицировать функции в регуляторе, которые были бы лучше реализованы вне его.
```c++
FastPID()
```
Создайте контроллер по умолчанию. Все коэффициенты по умолчанию равны нулю. Не используйте сконструированный по умолчанию контроллер до тех пор, пока вы не вызовете setCoefficients() и setOutputconfig()

```c++
FastPID(float kp, float ki, float kd, float hz, int bits=16, bool sign=false)
```
Постройте контроллер, который готов к работе. Вызывает следующие вызовы:
```c++
configure(kp, ki, kd, hz, bits, sign);

bool setCoefficients(float kp, float ki, float kd, float hz);
```
Настройка ПИД коэффициентов. Коэффициенты ki и kd масштабируются на величину hz. Значение hz информирует PID о скорости, которую вы назовете step(). Вызывающий код отвечает за вызов step() со скоростью в hz. Возвращает значение false, если произошла ошибка конфигурации. Что может быть связано с предыдущим вызовом.


bool setOutputConfig(int bits, bool sign);

Установите конфигурацию ouptut по битам/знаку. Диапазон выхода будет следующим:

Для знака, равного true  2^(n-1) - 1 вниз до -2^(n-1)

Для знака, равного false  2^n-1 вниз до 0

* ** bits равен 16-это особый случай. 
* ** Когда bits равен 16 и знак false диапазон выходных напряжений 32767 до 0

Возвращает значение false, если произошла ошибка конфигурации. Что может быть связано с предыдущим вызовом.
```c++
bool setOutputRange (int16_t min, int16_t max);
```
Установите диапазон ouptut непосредственно. Эффективный диапазон действия составляет:

* Мин:  от -32768 до 32766
* Макс: от -32767 до 32767

Min должно быть больше, чем max.

Возвращает значение false, если произошла ошибка конфигурации. Что может быть связано с предыдущим вызовом.
```c++
void clear();
```
Перезагрузите контроллер. Это должно быть сделано до того, как вы каким-либо образом измените конфигурацию.
```c++
bool configure(float kp, float ki, float kd, float hz, int bits=16, bool sign=false);
```
Массовая настройка контроллера. Эквивалентный:
```c++
clear();
setCoefficients(kp, ki, kd, hz);
setOutputConfig(bits, sign);

int16_t step(int16_t sp, int16_t fb);
```
Выполните один шаг контроллера и верните следующий вывод.
```c++
bool err();
```
Проверьте наличие ошибки конфиурации. Контроллер не будет работать, если эта функция возвращает true. 

#### Целочисленный Завод 

Приложения, которые управляют медленно движущимися системами и имеют ненулевой интегральный член, часто видят значительное превышение при запуске. 
Это вызвано интегральной суммой winidng up, поскольку она помнит долгое время вдали от заданной точки. Если это описывает вашу систему есть две вещи, которые вы можете сделать. 

##### Заводную решение: ограничить сумму 

В FastPID есть константы.h, которые контролируют максимально допустимый Интеграл. Понижение этих параметров предотвращает выход контроллера из строя. 
запоминание как можно большего смещения от заданного значения и позволит уменьшить превышение. 
```c++
#define INTEG_MAX    (INT32_MAX)
#define INTEG_MIN    (INT32_MIN)
```
Меняйте эти константы с осторожностью. Установка их слишком низко исправит вашу проблему превышения скорости, но это негативно скажется на способность регулятора регулировать нагрузку. Если вы не уверены в правильной константе используйте следующее решение вместо этого ограничения суммы. 

#### Ограничение Заводки: Ограниченное Регулирование 

Пид-контроллер лучше всего работает, когда система находится близко к заданному значению. Во время фазы запуска или в случае с a 
значительная экскурсия, вы можете полностью отключить пид-контроль. Пример этого можно найти в контроллере Sous-Vide 
пример в этом проекте. Ядро логики находится в этом коде: 
```c++
if (feedback < (setpoint * 0.9)) {
  analogWrite(PIN_OUTPUT, 1);
  myPID.clear();
}
else {
  analogWrite(PIN_OUTPUT, myPID.step(setpoint, feedback));
}
```
Код обходит ПИД, когда температура составляет менее 90% от заданного значения, просто включив нагреватель. Когда 
температура выше 90% от заданного значения пид включен. Фиксация вашего промаха таким образом дает вам гораздо лучший контроль
вашей системы без необходимости добавлять сложные, недопустимые и трудные для понимания функции к пид-контроллеру.

#### Sample Code 
```c++
#include <FastPID.h>

#define PIN_INPUT     A0
#define PIN_SETPOINT  A1
#define PIN_OUTPUT    9

float Kp=0.1, Ki=0.5, Kd=0.1, Hz=10;
int output_bits = 8;
bool output_signed = false;

FastPID myPID(Kp, Ki, Kd, Hz, output_bits, output_signed);

void setup()
{
  Serial.begin(9600);
  if (myPID.err()) {
    Serial.println("There is a configuration error!");
    for (;;) {}
  }
}

void loop()
{
  int setpoint = analogRead(PIN_SETPOINT) / 2; 
  int feedback = analogRead(PIN_INPUT);
  int ts = micros();
  uint8_t output = myPID.step(setpoint, feedback);
  int tss = micros();
  analogWrite(PIN_OUTPUT, output);
  Serial.print("(Fast) micros: "); 
  Serial.print(tss - ts);
  Serial.print(" sp: "); 
  Serial.print(setpoint); 
  Serial.print(" fb: "); 
  Serial.print(feedback);
  Serial.print(" out: ");
  Serial.println(output);
  delay(100);
}
```
### Справочная информация (подлежит уточнению)

|  код  |          имя            |            параметры            |           пример (данные, hex)            |
|-------|-------------------------|---------------------------------|-------------------------------------------|
| ответ	| 			  | cmd_err  			    | ошибка приема пакета                      |

#### Команды АЦП-преобразований

|  код  |          имя            |            параметры            |           пример (данные, hex)            |
|-------|-------------------------|---------------------------------|-------------------------------------------|
| 0x50	| cmd_adc_read_probes     |                                 |                                           |
| ответ	| 			  | adcU_h,l, adcI_h,l, 	    | 1F 00 1F 00                               |
|    	| 			  | adcD_h,l, adcC_h,l,             | 1F 00 1F 00                               |
|       |                         | mcr1, mcr2                      | 00 FF                                     |
| 0x52	| cmd_adc_config52        | nPrb, gain, ref, offset, mult   | 01 00 02 00 00 01 00                      |
| ответ	| 			  |                                 | 00                                        |
| 0x53	| cmd_adc_config53        | nPrb, bits, samples, divider    | 01 01 02 03                               |
| ответ	| 			  |                                 | 00                                        |
|       |                         |                                 |                                           | 

#### Команды ПИД-регулятора

|  код  |          имя            |            параметры            |           пример (данные, hex)            |
|-------|-------------------------|---------------------------------|-------------------------------------------|
| 0x40	| cmd_pid_configure       | kp, ki, kd, hz, bits, sign      | 00 19 00 80 00 00 0A 00 00 0A 00          |
| ответ	| 			  | 00 / 0x40                       | OK / ошибка параметра                     |
| 0x41	| cmd_pid_coefficients    | kp, ki, kd, hz                  | 00 19 00 80 00 00 0A 00                   |
| ответ	| 			  | 00 / 0x40                       | OK / ошибка параметра                     |
| 0x42	| cmd_pid_output_range    | min, max                        | 00 00 03 FF                               |
| ответ	| 			  | 00 / 0x40                       | OK / ошибка параметра                     |
| 0x43	| cmd_pid_output_config   | bits, sign                      | 10 00                                     |
| ответ	| 			  | 00 / 0x40                       | OK / ошибка параметра                     |
| 0x44	| cmd_pid_clear           |                                 |                                           |
| ответ	| 			  | 00 / 0x40                       | OK / ошибка параметра                     |
| 0x45	| cmd_pid_stop_go         | (стоп-пауза-пуск)               |                                           |
| ответ	| 			  | 00 / 0x40                       | OK / ошибка                               |
| 0x46	| cmd_pid_test            | res, mode, setpoint, min, max   | FF 03 01 FF 00 00 03 FF                   |
| ответ	| 			  | 00 / 0x40                       | OK / ошибка параметра                     |
| 0x47	|                         |                                 |                                           |
|       |                         |                                 |                                           | 
* kp, ki, kd, hz - целочисленные, полученные умножением на 256 (т.е << 8)